// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { registerRoute, NavigationRoute, Route } from 'workbox-routing';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { ExpirationPlugin } from 'workbox-expiration';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { warmStrategyCache } from 'workbox-recipes';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { BackgroundSyncPlugin } from 'workbox-background-sync';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { Queue } from 'workbox-background-sync';

// Clean up outdated caches
cleanupOutdatedCaches();

// Precache all assets generated by your build process
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
precacheAndRoute(self.__WB_MANIFEST);

// Add a utility function at the beginning of the file 
// to safely check if a URL can be cached
function isValidCacheURL(url: string): boolean {
  try {
    const urlObj = new URL(url);
    const validProtocols = ['http:', 'https:'];
    return validProtocols.includes(urlObj.protocol);
  } catch (e) {
    console.error('Invalid URL:', url, e);
    return false;
  }
}

// Define URLs to preload/warm up cache - expanded essential assets list
const URLS_TO_CACHE = [
  '/',
  '/index.html',
  '/manifest.json',
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png',
  '/offline.html',
  '/icons/add-task.png',
  '/icons/view-tasks.png',
  '/icons/badge.png',
  // Add core app routes
  '/home',
  '/upcoming',
  '/search',
  '/routine',
];

// Cache critical static assets with a Cache First strategy
const staticAssetsStrategy = new CacheFirst({
  cacheName: 'static-assets-v3',
  plugins: [
    new CacheableResponsePlugin({
      statuses: [0, 200],
    }),
    new ExpirationPlugin({
      maxEntries: 200, // Increased from 150
      maxAgeSeconds: 90 * 24 * 60 * 60, // 90 Days (increased from 30 days)
      purgeOnQuotaError: true // Delete old entries when cache is full
    }),
  ],
});

// Warm up the cache with critical assets
warmStrategyCache({
  urls: URLS_TO_CACHE,
  strategy: staticAssetsStrategy
});

// Cache images with a Cache First strategy
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ request, url }: { request: any, url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return request.destination === 'image';
  },
  new CacheFirst({
    cacheName: 'images-v3',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 150, // Increased from 100
        maxAgeSeconds: 90 * 24 * 60 * 60, // 90 Days (increased from 30 days)
        purgeOnQuotaError: true // Delete old entries when cache is full
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache CSS and JavaScript with a Stale While Revalidate strategy
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ request, url }: { request: any, url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return request.destination === 'script' ||
           request.destination === 'style';
  },
  new StaleWhileRevalidate({
    cacheName: 'static-resources-v3',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 150, // Increased from 100
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days (increased from 7 days)
        purgeOnQuotaError: true // Delete old entries when cache is full
      }),
    ],
  })
);

// Optimized caching for fonts to improve load time
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ request, url }: { request: any, url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return request.destination === 'font' || 
           url.origin.includes('fonts.googleapis.com') ||
           url.origin.includes('fonts.gstatic.com');
  },
  new CacheFirst({
    cacheName: 'fonts-v3',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50, // Increased from 30
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year (no change)
        purgeOnQuotaError: true // Delete old entries when cache is full
      }),
    ],
  })
);

// Enhanced caching for critical pages - improved implementation
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    
    // Cache Home, Upcoming, Search, and Routine page routes
    return url.pathname === '/' || 
           url.pathname === '/upcoming' || 
           url.pathname === '/search' ||
           url.pathname === '/routine' || 
           url.pathname === '/home' ||
           url.pathname === '/courses' ||
           url.pathname === '/profile' ||
           url.pathname.startsWith('/static/');
  },
  new NetworkFirst({
    cacheName: 'app-pages-v3',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50, // Increased from 30
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days (increased from 7 days)
        purgeOnQuotaError: true // Delete old entries when cache is full
      }),
    ],
  })
);

// Cache API calls with a Network First strategy
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return url.pathname.startsWith('/api/');
  },
  new NetworkFirst({
    cacheName: 'api-responses-v3',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 200, // Increased from 150
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days (increased from 24 hours)
        purgeOnQuotaError: true // Delete old entries when cache is full
      }),
    ],
  })
);

// Enhanced cache for critical data used in Home, Upcoming, Search, and Routine pages
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    } 
    return url.pathname.includes('/task') || 
           url.pathname.includes('/routine') || 
           url.pathname.includes('/user') ||
           url.pathname.includes('/course') ||
           url.pathname.includes('/teacher');
  },
  new NetworkFirst({
    cacheName: 'app-data-v3',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 150, // Increased from 100
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days (increased from 12 hours)
        purgeOnQuotaError: true // Delete old entries when cache is full
      }),
    ],
  })
);

// Add specific caching for Supabase REST API endpoints used by the Routine page
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    
    // Match Supabase endpoints for routines, courses, and teachers
    return (url.pathname.includes('/rest/v1/routines') || 
            url.pathname.includes('/rest/v1/routine_slots') ||
            url.pathname.includes('/rest/v1/courses') ||
            url.pathname.includes('/rest/v1/teachers')) &&
           url.searchParams.get('apikey') !== null;
  },
  new StaleWhileRevalidate({
    cacheName: 'supabase-api-v3',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 250, // Increased from 200
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days (increased from 24 hours)
        purgeOnQuotaError: true // Delete old entries when cache is full
      }),
    ],
  })
);

// Handle offline fallback
const OFFLINE_PAGE = '/offline.html';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
self.addEventListener('install', (event: any) => {
  // Skip waiting to activate the new service worker immediately
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (self as any).skipWaiting();
  
  event.waitUntil(
    caches.open('offline-cache-v3').then((cache) => {
      return cache.add(OFFLINE_PAGE);
    })
  );
});

// Claim clients to take control immediately
// eslint-disable-next-line @typescript-eslint/no-explicit-any
self.addEventListener('activate', (event: any) => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  event.waitUntil((self as any).clients.claim());
  
  // Clean up old caches
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames
          .filter(cacheName => {
            // Delete any old version caches (those that don't end with -v3)
            return !cacheName.endsWith('-v3') && 
                  (cacheName.startsWith('static-') || 
                   cacheName.startsWith('images-') || 
                   cacheName.startsWith('app-') ||
                   cacheName.startsWith('supabase-') ||
                   cacheName.startsWith('fonts-') ||
                   cacheName.startsWith('api-') ||
                   cacheName === 'offline-cache-v2');
          })
          .map(cacheName => {
            console.log('Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          })
      );
    })
  );
});

// SPA Routes that should be handled by the app's router
const SPA_ROUTES = [
  '/home',
  '/upcoming',
  '/search',
  '/notifications',
  '/courses',
  '/study-materials',
  '/routine',
  '/admin',
  '/settings',
  '/profile',
];

// Improved fetch event handling with specific SPA route support
// eslint-disable-next-line @typescript-eslint/no-explicit-any
self.addEventListener('fetch', (event: any) => {
  // Skip cross-origin requests and unsupported URL schemes
  if (!event.request.url.startsWith(self.location.origin) || 
      event.request.url.startsWith('chrome-extension://') ||
      event.request.url.startsWith('chrome://') ||
      event.request.url.startsWith('edge://') ||
      event.request.url.startsWith('brave://') ||
      !isValidCacheURL(event.request.url)) {
    return;
  }

  // Handle navigation requests
  if (event.request.mode === 'navigate') {
    const url = new URL(event.request.url);
    
    // Special handling for SPA routes - always serve index.html
    const isSpaRoute = SPA_ROUTES.some(route => 
      url.pathname === route || url.pathname.startsWith(`${route}/`)
    );
    
    if (isSpaRoute) {
      event.respondWith(
        caches.match('/index.html')
          .then(response => {
            if (response) {
              return response;
            }
            return fetch('/index.html');
          })
          .catch(() => {
            return caches.match(OFFLINE_PAGE);
          })
      );
      return;
    }
    
    event.respondWith(
      (async () => {
        try {
          // Try to perform a normal navigation
          const preloadResponse = await event.preloadResponse;
          if (preloadResponse) {
            return preloadResponse;
          }

          // Try the network first for navigation
          const networkResponse = await fetch(event.request);
          // Save successful responses in cache
          const cache = await caches.open('app-pages-v3');
          cache.put(event.request, networkResponse.clone());
          return networkResponse;
        } catch (error) {
          // If network fails, try to get the page from cache
          const cache = await caches.open('app-pages-v3');
          const cachedResponse = await cache.match(event.request);
          if (cachedResponse) {
            return cachedResponse;
          }

          // If the page isn't in cache, return the offline page
          const offlineCache = await caches.open('offline-cache-v3');
          const offlineResponse = await offlineCache.match(OFFLINE_PAGE);
          return offlineResponse;
        }
      })()
    );
  }
});

// Create separate queues for different API operations
const taskSyncQueue = new Queue('taskQueue', {
  maxRetentionTime: 24 * 60 // Retry for up to 24 Hours (in minutes)
});

const routineSyncQueue = new Queue('routineQueue', {
  maxRetentionTime: 24 * 60 // Retry for up to 24 Hours
});

const courseTeacherSyncQueue = new Queue('courseTeacherQueue', {
  maxRetentionTime: 24 * 60 // Retry for up to 24 Hours
});

// Create plugins from queues for the background sync
const taskBgSyncPlugin = new BackgroundSyncPlugin('taskQueue', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 Hours
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request.clone());
        console.log('Sync successful for task operation');
        
        // Notify the client that sync is complete
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const clients = await (self as any).clients.matchAll({ type: 'window' });
        for (const client of clients) {
          client.postMessage({
            type: 'BACKGROUND_SYNC_COMPLETED',
            category: 'task'
          });
        }
      } catch (error) {
        console.error('Sync failed for task:', error);
        // Put the entry back in the queue and rethrow the error
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
});

const routineBgSyncPlugin = new BackgroundSyncPlugin('routineQueue', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 Hours
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request.clone());
        console.log('Sync successful for routine operation');
        
        // Notify the client that sync is complete
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const clients = await (self as any).clients.matchAll({ type: 'window' });
        for (const client of clients) {
          client.postMessage({
            type: 'BACKGROUND_SYNC_COMPLETED',
            category: 'routine'
          });
        }
      } catch (error) {
        console.error('Sync failed for routine:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
});

const courseTeacherBgSyncPlugin = new BackgroundSyncPlugin('courseTeacherQueue', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 Hours
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request.clone());
        console.log('Sync successful for course/teacher operation');
        
        // Notify the client that sync is complete
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const clients = await (self as any).clients.matchAll({ type: 'window' });
        for (const client of clients) {
          client.postMessage({
            type: 'BACKGROUND_SYNC_COMPLETED',
            category: 'courseTeacher'
          });
        }
      } catch (error) {
        console.error('Sync failed for course/teacher:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
});

// Updated API routes for tasks with background sync
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return url.pathname.match(/\/api\/tasks.*/);
  },
  new NetworkFirst({
    cacheName: 'tasks-api-v3',
    plugins: [taskBgSyncPlugin]
  }),
  'POST'
);

registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return url.pathname.match(/\/api\/tasks.*/);
  },
  new NetworkFirst({
    cacheName: 'tasks-api-v3',
    plugins: [taskBgSyncPlugin]
  }),
  'PUT'
);

registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return url.pathname.match(/\/api\/tasks.*/);
  },
  new NetworkFirst({
    cacheName: 'tasks-api-v3',
    plugins: [taskBgSyncPlugin]
  }),
  'DELETE'
);

// Updated API routes for routines with background sync
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return url.pathname.match(/\/api\/routines.*/);
  },
  new NetworkFirst({
    cacheName: 'routines-api-v3',
    plugins: [routineBgSyncPlugin]
  }),
  'POST'
);

registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return url.pathname.match(/\/api\/routines.*/);
  },
  new NetworkFirst({
    cacheName: 'routines-api-v3',
    plugins: [routineBgSyncPlugin]
  }),
  'PUT'
);

registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return url.pathname.match(/\/api\/routines.*/);
  },
  new NetworkFirst({
    cacheName: 'routines-api-v3',
    plugins: [routineBgSyncPlugin]
  }),
  'DELETE'
);

// Updated API routes for courses & teachers with background sync
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return url.pathname.match(/\/api\/(courses|teachers).*/);
  },
  new NetworkFirst({
    cacheName: 'course-teacher-api-v3',
    plugins: [courseTeacherBgSyncPlugin]
  }),
  'POST'
);

registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return url.pathname.match(/\/api\/(courses|teachers).*/);
  },
  new NetworkFirst({
    cacheName: 'course-teacher-api-v3',
    plugins: [courseTeacherBgSyncPlugin]
  }),
  'PUT'
);

registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return url.pathname.match(/\/api\/(courses|teachers).*/);
  },
  new NetworkFirst({
    cacheName: 'course-teacher-api-v3',
    plugins: [courseTeacherBgSyncPlugin]
  }),
  'DELETE'
);

// Handle sync events directly
// eslint-disable-next-line @typescript-eslint/no-explicit-any
self.addEventListener('sync', (event: any) => {
  console.log('Sync event received:', event.tag);
  
  if (event.tag === 'taskSync') {
    event.waitUntil(taskSyncQueue.replayRequests());
  } else if (event.tag === 'routineSync') {
    event.waitUntil(routineSyncQueue.replayRequests());
  } else if (event.tag === 'courseTeacherSync') {
    event.waitUntil(courseTeacherSyncQueue.replayRequests());
  }
});

// Add a global error handler to catch unexpected errors
self.addEventListener('error', (event) => {
  console.error('Service Worker error:', event.error);
});

// Add an unhandled rejection handler
self.addEventListener('unhandledrejection', (event) => {
  console.error('Service Worker unhandled rejection:', event.reason);
});

// Add a message handler for keep-alive pings
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'KEEP_ALIVE') {
    console.log('Keep-alive ping received at', new Date(event.data.timestamp).toISOString());
    
    // Respond to the keep-alive to confirm service worker is active
    if (event.source) {
      event.source.postMessage({
        type: 'KEEP_ALIVE_RESPONSE',
        timestamp: Date.now()
      });
    }
    
    // Reset any internal timers to keep the service worker active
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    self.registration.active?.postMessage({
      type: 'INTERNAL_KEEP_ALIVE'
    });
  } else if (event.data && event.data.type === 'SYNC_NOW') {
    console.log('SYNC_NOW message received, attempting immediate sync');
    
    // Try to perform sync for all queues
    Promise.allSettled([
      taskSyncQueue.replayRequests(),
      routineSyncQueue.replayRequests(),
      courseTeacherSyncQueue.replayRequests()
    ]).then(results => {
      console.log('Sync attempts completed:', results);
      
      // Notify client that sync was attempted
      if (event.source) {
        event.source.postMessage({
          type: 'SYNC_NOW_COMPLETED',
          results: results.map(r => r.status)
        });
      }
    });
  }
});